#!/usr/local/bin/python
# -*- coding: utf-8 -*-

import numpy as np
from cmath import rect, polar, phase, pi, exp
from envelope import Exponential
from generators import Generator
from utils import play, write

np.set_printoptions(precision=4, suppress=True)


class Noise(object, Generator):
    """Noise generator"""

    def __init__(self, function='white'):
        self.function = function

    def sample(self, iter, e = Exponential(-2, amp=0.25)):
        amps = np.random.random(len(iter))
        angles = np.random.random(len(iter)) * 1j * 2.0 * pi
        noise = amps * np.exp(angles)
        # noise = (2.0 * amps - 1.0) * 1j   # flat
        # e = Exponential(0, amp=float(freq)/o.frequency*float(freq)) # square waves
        return noise[iter] * e[iter]


class Rustle(object, Generator):
    """Rustle noise generator.
    
    Rustle noise is noise consisting of aperiodic pulses characterized by 
    the average time between those pulses (such as the mean time interval 
    between clicks of a Geiger counter), known as rustle time.
    
    Rustle time is determined by the fineness of sand, seeds, or shot in 
    rattles, contributes heavily to the sound of sizzle cymbals, drum snares, 
    drum rolls, and string drums, and makes subtle differences in 
    string instrument sounds.
    
    TODO: Try noises generated by random walks or something else here!
    
    See: http://en.wikipedia.org/wiki/Rustle_noise
    """
    pass


class Chaos(object, Generator):
    """Chaos generator"""

    def __init__(self):
        self.gen = self.Mandelbrot()

    def sample(self, iter, e = Exponential(0, amp=0.5)):
        chaos = np.fromiter(self.gen, count=len(iter), dtype=complex)
        return chaos[iter] * e[iter]

    def __repr__(self):
        return "Mandelbrot: c=%s, z=%s" % (self.gen.c, self.gen.z)


    # Generator function class for Chaos
    class Mandelbrot:

        @staticmethod
        def random_phasor():
            return rect(np.random.random(), 2 * pi * np.random.random())

        def __init__(self, c=None, random=False):
            if c:
                self.c = c
            else:
                self.c = rect(np.random.random(), 2 * pi * np.random.random() * 1.0/8.0)
            if random:
                self.seed()
            else:
                self.z = 0

        def next(self):
            self.z = self.mandelbrot(self.z)
            if abs(self.z) > 1.0:
                self.z = rect(1.0/abs(self.z), phase(self.z))
            return self.z

        def seed(self):
            self.z = self.random_phasor()

        def __iter__(self):
            return self

        def __contains__(self, z):
            if abs(z) < 1.0:
                return True
            else:
                return False

        def mandelbrot(self,z):
            # mandel = np.poly1d([1, 0, self.c])
            return z**2 + self.c