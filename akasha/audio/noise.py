#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Noise and chaos module.
"""

from __future__ import division

import numpy as np
import pandas as pd

from cmath import rect
from funckit import xoltar as fx

from akasha.audio.curves import Circle
from akasha.audio.envelope import Exponential
from akasha.audio.frequency import Frequency
from akasha.audio.generators import Generator
from akasha.utils.math import normalize, numberof, pi2, random_phasor
from akasha.timing import sampler


class Noise(Generator):
    """
    Noise generator with a domain function (unit square or disc).
    """

    def __init__(self, domain_fn=None, random_fn=np.random.random):
        super(self.__class__, self).__init__()
        self.function = domain_fn or self.unit_disc
        self.randomizer = random_fn

    @staticmethod
    def unit_disc(iterable, randomizer, *args, **kwargs):
        """
        Noise generating function for the unit disc domain.
        """
        amps = randomizer(*args, size=len(iterable), **kwargs)
        angles = randomizer(*args, size=len(iterable), **kwargs) * 1j * pi2
        noise = amps * np.exp(angles)
        # noise = (2.0 * amps - 1.0) * 1j   # flat
        return noise

    @staticmethod
    def unit_square(iterable, randomizer, *args, **kwargs):
        """
        Noise generating function for the unit square domain.
        """
        x = 2 * randomizer(*args, size=len(iterable), **kwargs) - 1.0
        y = 2j * randomizer(*args, size=len(iterable), **kwargs) - 1.0j
        noise = x + y
        return noise

    def sample(self, iterable):
        """
        Commence noise.
        """
        return self.function(iterable, self.randomizer)


class ColouredNoise(Generator):
    """
    Generate coloured noise, with instantaneous frequency differences having some distribution.
    By default uses standard normal distribution, also known as the Gaussian distribution.
    """
    # TODO Make this into a filter for jittering a frequency
    # TODO Examine using other distributions

    def __init__(self, frequency, deviation=0.1, step=1, log=True):
        """
        == Parameters ==
        frequency: The center of the distribution (mu).
        deviation: The standard deviation (sigma).

        Example:
        >>> cn = ColouredNoise(0.01, 0.1)
        """
        self.frequency = Frequency(frequency)
        self.sigma = deviation
        self.step = step
        self.randomizer = np.random.lognormal if log else np.random.normal

    @property
    def mu(self):
        return self.frequency.ratio

    def sample(self, iterable):
        length = len(iterable)
        s = self.randomizer(self.mu, self.sigma, np.ceil(length / float(self.step)))
        if self.step != 1:
            s = np.interp(np.arange(length), np.arange(0, length, self.step), s[:length])
        return c.at(np.cumsum(s))


class Rustle(Generator):
    """
    Rustle noise generator.

    Rustle noise is noise consisting of aperiodic pulses characterized by
    the average time between those pulses (such as the mean time interval
    between clicks of a Geiger counter), known as rustle time.

    Rustle time is determined by the fineness of sand, seeds, or shot in
    rattles, contributes heavily to the sound of sizzle cymbals, drum snares,
    drum rolls, and string drums, and makes subtle differences in
    string instrument sounds.

    TODO: Try noises generated by random walks or something else here!

    See: http://en.wikipedia.org/wiki/Rustle_noise
    """
    def __init__(self, expected=1, frequency=1, envelope=Exponential(0)):
        self.frequency = Frequency(frequency)
        self.expected = expected
        self.gen = fx.curry_function(np.random.poisson, self.expected)
        self.envelope = envelope

    def sample(self, items):
        """
        Let it rumble and rustle.
        """
        return self.envelope[items] * normalize(
            self.gen(numberof(items)) * Circle.at(self.frequency[items])
        )


class Mandelbrot(Generator):
    """
    Mandelbrot set generator for Chaos.

    The regular Mandelbrot set is slightly different from this:
    The iterator is always kept inside the unit disc.
    """
    def __init__(self, z=None, c=None, random=False):
        super(self.__class__, self).__init__()

        if random:
            self.z = random_phasor()[0]
        else:
            self.z = z if z is not None else 0
        self.c = c if c is not None else random_phasor()[0]

    def __iter__(self):
        return self

    def next(self):
        """
        Get the next sample from mandelbrot set, and if the diverges,
        make it's magnitude to be 1/abs(z) to keep it inside unit circle.
        """
        self.z = self.poly(self.z)
        if np.abs(self.z) > 1.0:
            self.z = np.array(rect(1.0 / np.abs(self.z), np.angle(self.z)), dtype=complex)
        return self.z

    def poly(self, z):
        """
        Mandelbrot set generating function.
        """
        # TODO: Generalize the kernel (the variable mandel) using np.poly1d
        # vvvv     z ** 2 (+ 0 ** 1) + c =
        # mandel = np.poly1d([1, 0, self.c])
        return z ** 2 + self.c

    def sample(self, items):
        """
        Chaos reigns.
        """
        return np.fromiter(self, count=numberof(items), dtype=complex)

    def __repr__(self):
        return "%s(z=%s, c=%s)" % (self.__class__.__name__, self.c, self.z)


class Chaos(Generator):
    """
    Chaos ensues.
    """
    # TODO: Make into generic iterator using Generator

    def __init__(self, gen=Mandelbrot(random=True), envelope=Exponential(0, amp=0.5)):
        super(self.__class__, self).__init__()
        self.gen = gen
        self.envelope = envelope  # TODO: Leave out of sound objects, and compose when sampling?

    def sample(self, iterable):
        """
        Chaos reigns.
        """
        print(self.gen, len(iterable))
        chaos = np.fromiter(self.gen, count=len(iterable), dtype=complex)
        return chaos[iterable] * self.envelope[iterable]

    def __repr__(self):
        return "%s(gen=%s)" % (self.__class__.__name__, repr(self.gen))


def random_frequencies(n, low=20, high=sampler.rate/2.0, t=4, window=2, smoothing='exponential'):
    signal = np.repeat(
        np.random.random_integers(
            low, high, np.ceil(float(n) / float(t))) / float(sampler.rate),
        t)
    if smoothing == 'exponential':
        signal = pd.ewma(signal, span=window, min_periods=1)
    elif smoothing:
        signal = pd.rolling_mean(signal, window=window, min_periods=1)
    return np.exp(1j * pi2 * np.cumsum(signal))
