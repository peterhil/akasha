#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Noise and chaos module.
"""

import numpy as np

from cmath import rect

from akasha.audio.curves import Circle
from akasha.audio.envelope import Exponential
from akasha.audio.frequency import Frequency
from akasha.audio.generators import Generator
from akasha.funct.xoltar import functional as fx
from akasha.utils.math import normalize, numberof, pi2, random_phasor


class Noise(Generator):
    """
    Noise generator with a domain function (unit square or disc).
    """

    def __init__(self, domain_fn=None, random_fn=np.random.random):
        super(self.__class__, self).__init__()
        self.function = domain_fn or self.unit_disc
        self.randomizer = random_fn

    @staticmethod
    def unit_disc(iterable, randomizer, *args, **kwargs):
        """
        Noise generating function for the unit disc domain.
        """
        amps = randomizer(*args, size=len(iterable), **kwargs)
        angles = randomizer(*args, size=len(iterable), **kwargs) * 1j * pi2
        noise = amps * np.exp(angles)
        # noise = (2.0 * amps - 1.0) * 1j   # flat
        return noise

    @staticmethod
    def unit_square(iterable, randomizer, *args, **kwargs):
        """
        Noise generating function for the unit square domain.
        """
        x = 2 * randomizer(*args, size=len(iterable), **kwargs) - 1.0
        y = 2j * randomizer(*args, size=len(iterable), **kwargs) - 1.0j
        noise = x + y
        return noise

    def sample(self, iterable):
        """
        Commence noise.
        """
        return self.function(iterable, self.randomizer)


class Rustle(Generator):
    """
    Rustle noise generator.

    Rustle noise is noise consisting of aperiodic pulses characterized by
    the average time between those pulses (such as the mean time interval
    between clicks of a Geiger counter), known as rustle time.

    Rustle time is determined by the fineness of sand, seeds, or shot in
    rattles, contributes heavily to the sound of sizzle cymbals, drum snares,
    drum rolls, and string drums, and makes subtle differences in
    string instrument sounds.

    TODO: Try noises generated by random walks or something else here!

    See: http://en.wikipedia.org/wiki/Rustle_noise
    """
    def __init__(self, expected=1, frequency=1, envelope=Exponential(0)):
        self.frequency = Frequency(frequency)
        self.expected = expected
        self.gen = fx.curry(np.random.poisson, self.expected)
        self.envelope = envelope

    def sample(self, items):
        """
        Let it rumble and rustle.
        """
        return self.envelope[items] * normalize(
            self.gen(numberof(items)) * Circle.at(self.frequency[items])
        )


class Mandelbrot(Generator):
    """
    Mandelbrot set generator for Chaos.

    The regular Mandelbrot set is slightly different from this:
    The iterator is always kept inside the unit disc.
    """
    def __init__(self, z=None, c=None, random=False):
        super(self.__class__, self).__init__()

        if random:
            self.z = random_phasor()
        else:
            self.z = z if z is not None else 0
        self.c = c if c is not None else random_phasor()

    def __iter__(self):
        return self

    def next(self):
        """
        Get the next sample from mandelbrot set, and if the diverges,
        make it's magnitude to be 1/abs(z) to keep it inside unit circle.
        """
        self.z = self.poly(self.z)
        if np.abs(self.z) > 1.0:
            self.z = np.array(rect(1.0 / np.abs(self.z), np.angle(self.z)), dtype=complex)
        return self.z

    def poly(self, z):
        """
        Mandelbrot set generating function.
        """
        # TODO: Generalize the kernel (the variable mandel) using np.poly1d
        # vvvv     z ** 2 (+ 0 ** 1) + c =
        # mandel = np.poly1d([1, 0, self.c])
        return z ** 2 + self.c

    def sample(self, items):
        """
        Chaos reigns.
        """
        return np.fromiter(self, count=numberof(items), dtype=complex)

    def __repr__(self):
        return "%s(z=%s, c=%s)" % (self.__class__.__name__, self.c, self.z)


class Chaos(Generator):
    """
    Chaos ensues.
    """
    # TODO: Make into generic iterator using Generator

    def __init__(self, gen=Mandelbrot, envelope=Exponential(0, amp=0.5)):
        super(self.__class__, self).__init__()
        self.gen = gen
        self.envelope = envelope  # TODO: Leave out of sound objects, and compose when sampling?

    def sample(self, iterable):
        """
        Chaos reigns.
        """
        print(self.gen, len(iterable))
        chaos = np.fromiter(self.gen, count=len(iterable), dtype=complex)
        return chaos[iterable] * self.envelope[iterable]

    def __repr__(self):
        return "%s(gen=%s)" % (self.__class__.__name__, repr(self.gen))
