#!/usr/bin/env python
#
# E1101: Module 'x' has no 'y' member
#
# pylint: disable=E1101

"""
Noise and chaos module.
"""


from cmath import rect

import funcy
import numpy as np
import pandas as pd

from akasha.curves import Circle
from akasha.audio.envelope import Exponential
from akasha.audio.frequency import Frequency
from akasha.audio.generators import Generator
from akasha.math import normalize, numberof, pi2, random_phasor
from akasha.timing import sampler
from akasha.utils.python import class_name, _super


class Noise(Generator):
    """
    Noise generator with a domain function (unit square or disc).
    """

    def __init__(self, domain_fn=None, random_fn=np.random.random):
        _super(self).__init__()
        self.function = domain_fn or self.unit_disc
        self.randomizer = random_fn

    @staticmethod
    def unit_disc(iterable, randomizer, *args, **kwargs):
        """
        Noise generating function for the unit disc domain.
        """
        amps = randomizer(*args, size=len(iterable), **kwargs)
        angles = randomizer(*args, size=len(iterable), **kwargs) * 1j * pi2
        noise = amps * np.exp(angles)
        # noise = (2.0 * amps - 1.0) * 1j   # flat
        return noise

    @staticmethod
    def unit_square(iterable, randomizer, *args, **kwargs):
        """
        Noise generating function for the unit square domain.
        """
        x = 2 * randomizer(*args, size=len(iterable), **kwargs) - 1.0
        y = 2j * randomizer(*args, size=len(iterable), **kwargs) - 1.0j
        noise = x + y
        return noise

    def sample(self, frames):
        """
        Commence noise.
        """
        return self.function(frames, self.randomizer)


class ColouredNoise(Generator):
    """Generate coloured noise, with instantaneous frequency
    differences having some distribution.

    By default uses standard normal distribution, also known as
    the Gaussian distribution.
    """

    # TODO Make this into a filter for jittering a frequency
    # TODO Examine using other distributions

    def __init__(
        self,
        frequency,
        deviation=0.1,
        step=1,
        curve=Circle(),
        log=True
    ):
        """== Parameters ==
        frequency: The center of the distribution (mu).
        deviation: The standard deviation (sigma).

        Example:
        >>> cn = ColouredNoise(0.01, 0.1)
        """
        self.curve = curve
        self.frequency = Frequency(frequency)
        self.sigma = deviation
        self.step = step
        self.randomizer = np.random.lognormal if log else np.random.normal

    @property
    def mu(self):
        """
        Center of the distribution.
        """
        return self.frequency.ratio

    def sample(self, frames):
        length = len(frames)
        num = int(np.ceil(length / float(self.step)))
        signal = self.randomizer(self.mu, self.sigma, num)

        if self.step != 1:
            signal = np.interp(
                np.arange(length),
                np.arange(0, length, self.step),
                signal[:length],
            )
        w = self.frequency.at(np.cumsum(signal))

        return self.curve.at(w)


class Rustle(Generator):
    """
    Rustle noise generator.

    Rustle noise is noise consisting of aperiodic pulses characterized by
    the average time between those pulses (such as the mean time interval
    between clicks of a Geiger counter), known as rustle time.

    Rustle time is determined by the fineness of sand, seeds, or shot in
    rattles, contributes heavily to the sound of sizzle cymbals, drum snares,
    drum rolls, and string drums, and makes subtle differences in
    string instrument sounds.

    TODO: Try noises generated by random walks or something else here!

    See: http://en.wikipedia.org/wiki/Rustle_noise
    """

    def __init__(self, expected=1, frequency=1, envelope=Exponential(0)):
        self.frequency = Frequency(frequency)
        self.expected = expected
        self.gen = funcy.curry(np.random.poisson, 2)(self.expected)
        self.envelope = envelope

    def at(self, t):
        """
        Let it rumble and rustle.
        """
        return self.envelope.at(t) * normalize(
            self.gen(numberof(t)) * Circle.at(self.frequency.at(t))
        )


class Mandelbrot(Generator):
    """
    Mandelbrot set generator for Chaos.

    The regular Mandelbrot set is slightly different from this:
    The iterator is always kept inside the unit disc.
    """

    def __init__(self, z=None, c=None, random=False):
        _super(self).__init__()

        if random:
            self.z = random_phasor()[0]
        else:
            self.z = z if z is not None else 0
        self.c = c if c is not None else random_phasor()[0]

    def __iter__(self):
        return self

    def next(self):
        """
        Get the next sample from mandelbrot set, and if the diverges,
        make it's magnitude to be 1/abs(z) to keep it inside unit circle.
        """
        self.z = self.poly(self.z)
        if np.abs(self.z) > 1.0:
            self.z = np.array(
                rect(1.0 / np.abs(self.z), np.angle(self.z)), dtype=complex
            )
        return self.z

    def poly(self, z):
        """
        Mandelbrot set generating function.
        """
        # TODO: Generalize the kernel (the variable mandel) using np.poly1d
        # vvvv     z ** 2 (+ 0 ** 1) + c =
        # mandel = np.poly1d([1, 0, self.c])
        return z ** 2 + self.c

    def sample(self, frames):
        """
        Chaos reigns.
        """
        return np.fromiter(self, count=numberof(frames), dtype=complex)

    def __repr__(self):
        return f'{class_name(self)}(z={self.z!r}, z={self.c!r})'


class Chaos(Generator):
    """
    Chaos ensues.
    """

    # TODO: Make into generic iterator using Generator

    def __init__(
        self,
        gen=Mandelbrot(random=True),
        envelope=Exponential(0, amp=0.5),
    ):
        _super(self).__init__()
        self.gen = gen
        # TODO: Leave envelope out of sound objects & compose when sampling?
        self.envelope = envelope

    def sample(self, frames):
        """
        Chaos reigns.
        """
        print(self.gen, len(frames))
        chaos = np.fromiter(self.gen, count=len(frames), dtype=complex)
        return chaos[frames] * self.envelope[frames]

    def __repr__(self):
        return f'{class_name(self)}(gen={self.gen!r})'


def random_frequencies(
    n,
    low=20,
    high=sampler.rate / 2.0,
    t=4,
    window=2,
    smoothing='exponential',
):
    """
    Generate random varying frequencies using window functions.
    """
    signal = np.repeat(
        np.random.random_integers(low, high, np.ceil(float(n) / float(t)))
        / float(sampler.rate),
        t,
    )
    if smoothing == 'exponential':
        signal = pd.ewma(signal, span=window, min_periods=1)
    elif smoothing:
        signal = pd.rolling_mean(signal, window=window, min_periods=1)
    return np.exp(1j * pi2 * np.cumsum(signal))
