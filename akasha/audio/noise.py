#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import absolute_import

import numpy as np

from cmath import rect, polar, phase, pi, exp

from .envelope import Exponential
from .generators import Generator


class Noise(Generator):
    """Round (magnitude 0..1 with random angle) or polar noise generator"""

    def __init__(self, domain_fn=None, random_fn=np.random.random):
        self.function = domain_fn or self.unit_disc
        self.randomizer = random_fn

    @staticmethod
    def unit_disc(iter, randomizer, *args, **kwargs):
        amps = randomizer(*args, size=len(iter), **kwargs)
        angles = randomizer(*args, size=len(iter), **kwargs) * 1j * 2.0 * pi
        noise = amps * np.exp(angles)
        # noise = (2.0 * amps - 1.0) * 1j   # flat
        return noise

    @staticmethod
    def unit_square(iter, randomizer, *args, **kwargs):
        x = 2 * randomizer(*args, size=len(iter), **kwargs) - 1.0
        y = 2j * randomizer(*args, size=len(iter), **kwargs) - 1.0j
        noise = x + y
        print noise, type(noise)
        return noise

    def sample(self, iter):
        return self.function(iter, self.randomizer)


class Rustle(Generator):
    """Rustle noise generator.

    Rustle noise is noise consisting of aperiodic pulses characterized by
    the average time between those pulses (such as the mean time interval
    between clicks of a Geiger counter), known as rustle time.

    Rustle time is determined by the fineness of sand, seeds, or shot in
    rattles, contributes heavily to the sound of sizzle cymbals, drum snares,
    drum rolls, and string drums, and makes subtle differences in
    string instrument sounds.

    TODO: Try noises generated by random walks or something else here!

    See: http://en.wikipedia.org/wiki/Rustle_noise
    """
    pass


class Chaos(Generator):
    """Chaos generator"""

    def __init__(self):
        self.gen = self.Mandelbrot()

    def sample(self, iter, e = Exponential(0, amp=0.5)):
        chaos = np.fromiter(self.gen, count=len(iter), dtype=complex)
        return chaos[iter] * e[iter]

    def __repr__(self):
        return "Mandelbrot: c=%s, z=%s" % (self.gen.c, self.gen.z)


    # Generator function class for Chaos
    class Mandelbrot:

        @staticmethod
        def random_phasor():
            return rect(np.random.random(), 2 * pi * np.random.random())

        def __init__(self, c=None, random=False):
            if c:
                self.c = c
            else:
                self.c = rect(np.random.random(), 2 * pi * np.random.random() * 1.0/8.0)
            if random:
                self.seed()
            else:
                self.z = 0

        def next(self):
            self.z = self.mandelbrot(self.z)
            if abs(self.z) > 1.0:
                self.z = rect(1.0/abs(self.z), phase(self.z))
            return self.z

        def seed(self):
            self.z = self.random_phasor()

        def __iter__(self):
            return self

        def __contains__(self, z):
            if abs(z) < 1.0:
                return True
            else:
                return False

        def mandelbrot(self,z):
            # mandel = np.poly1d([1, 0, self.c])
            return z**2 + self.c
